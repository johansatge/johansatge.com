package js{		import flash.display.MovieClip;	import flash.display.Shape;	import flash.display.CapsStyle;	import flash.events.Event;	import flash.display.Bitmap;	import flash.filters.BlurFilter;	import flash.filters.BitmapFilterQuality;	import flash.display.BlendMode;	import com.greensock.TweenLite	import com.greensock.easing.Linear;	import com.greensock.easing.Back;	import com.greensock.easing.Cubic;		public class CircularLoader extends MovieClip	{		private var radius:Number; 		private var lineWeight:Number;		private var circleShape:Shape;		private var fullscreenBackground:MovieClip;		private var bitmapBackground:Bitmap;		private var backColor:uint;		private var theMask:MovieClip;		private var maskBlurFilter:BlurFilter;		private var blurWeight:int;		public var maskRadius:Number;			/**		 * Constructor.		 * @param	Number	radius				the radius of the progress circle		 * @param	Bitmap	backgroundBitmap	the background picture		 * @param	uint	backColor			the background color		 * @param	int		blurWeight			the weight of the blur user when hiding the object		 */		public function CircularLoader(radius:Number , backgroundBitmap:Bitmap , backColor:uint , blurWeight:int)		{			// Inits vars			this.radius = radius / 2;			this.lineWeight = 8;			this.bitmapBackground = backgroundBitmap;			this.backColor = backColor;			this.blurWeight = blurWeight;			if (stage)				this.addedToStage(null);			else				this.addEventListener(Event.ADDED_TO_STAGE , this.addedToStage);		}				/**		 * Clear the object		 * @return	void		 */		public function destroy():void		{			this.removeChild(this.fullscreenBackground);			this.removeChild(this.theMask);			this.removeChild(this.circleShape);			this.fullscreenBackground = null;			this.theMask = null;			this.circleShape = null;		}		/**		 * Fired when added to stage		 * @param	Event	evt		the event		 * @return	void		 */		private function addedToStage(evt:Event = null):void		{			if (evt != null)				evt.target.removeEventListener(Event.ADDED_TO_STAGE , this.addedToStage);			this.blendMode = BlendMode.LAYER;			// Inits the mask			this.maskBlurFilter = new BlurFilter(this.blurWeight , this.blurWeight , BitmapFilterQuality.LOW);			this.theMask = new MovieClip();			this.theMask.cacheAsBitmap = true;			this.theMask.blendMode = BlendMode.ERASE;			this.theMask.filters = [this.maskBlurFilter];			// Inits background			this.fullscreenBackground = new MovieClip();			this.fullscreenBackground.addChild(this.bitmapBackground);			this.fullscreenBackground.cacheAsBitmap = true;			this.bitmapBackground.alpha = 0;			this.addChild(this.fullscreenBackground);			this.addChild(this.theMask);			// Inits loader			this.circleShape = new Shape();			this.circleShape.rotation = -90;			this.circleShape.scaleX = 0;			this.circleShape.scaleY = 0;			this.addChild(this.circleShape);			this.updateLoader();		}		/**		 * Displays the loader		 * @param	Function	callback		the function to call when the animation is done		 * @param	Number		displaySpeed	the speed of the animation		 * @param	Number		delay			the delay before the loader is displayed		 * @return	void		 */		public function displayLoader(callback:Function , displaySpeed:Number , delay:Number):void		{			TweenLite.to(this.bitmapBackground , displaySpeed , {delay:delay , alpha:1 , ease:Linear.easeNone});			TweenLite.to(this.circleShape , displaySpeed , {delay:delay , scaleX:1 , scaleY:1 , ease:Back.easeOut});			TweenLite.delayedCall(displaySpeed + delay , callback);		}				/**		 * Hides the loader		 * @param	Function	callback		the function to call after a given delay		 * @param	Number		callbackDelay	the delay		 * @param	FUnctiuon	finalFunction	called when the animation is done		 * @param	int			contextWidth	the width of the context		 * @param	int			contextHeight	the height of the context		 * @param	Number		displaySpeed	the speed of the animation		 * @return	void		 */		public function displayBackground(callback:Function , callbackDelay:Number , finalCallback:Function , displaySpeed:Number):void		{			// Prepares			this.maskRadius = 0;			this.circleShape.alpha = 0;			var theDiagonal:int = getDiagonal(stage.stageWidth , stage.stageHeight) + (this.blurWeight * 2);			this.drawHidingMask();			this.theMask.graphics.clear();			this.theMask.graphics.beginFill(0xffffff);			this.theMask.graphics.drawCircle(0 , 0 , 100);			this.theMask.graphics.endFill();			// Tweens			//TweenLite.to(this , displaySpeed , {alpha:0 , maskRadius: theDiagonal , onUpdate:drawHidingMask , ease:Linear.easeNone});			TweenLite.to(this , displaySpeed , {alpha:0});			TweenLite.delayedCall(callbackDelay , callback);			TweenLite.delayedCall(displaySpeed , backgroundDisplayed , [finalCallback]);		}		/**		 * Loader has been displayed		 * @param	Function	callback	the function to call when the animation is done		 * @return	void		 */		private function backgroundDisplayed(callback:Function):void		{			callback();			this.destroy();		}				/**		 * Draws the mask when hiding the loader		 * @return	void		 */		private function drawHidingMask():void		{			this.theMask.width = this.maskRadius;			this.theMask.height = this.maskRadius;			this.theMask.x = int(stage.stageWidth / 2);			this.theMask.y = int(stage.stageHeight / 2);		}				/**		 * Returns the diagonal length of the given context		 * @param	int			contextWidth	the width of the context		 * @param	int			contextHeight	the height of the context		 * @return	Number		 */		private function getDiagonal(contextWidth:int , contextHeight:int):Number		{			return Math.sqrt(Math.pow((contextWidth) / 2 , 2) + Math.pow((contextHeight) / 2 , 2));		}		/**		 * Updates the loader		 * @param	Number	progressPercentage	the percentage (optional)		 * @return	void		 */		public function updateLoader(progressPercentage:Number = 0):void		{			// Draws circle			var angle:Number = (100 - progressPercentage) / 100 * 360;			this.circleShape.graphics.clear();			this.circleShape.graphics.lineStyle (this.lineWeight , 0xffffff , 1 , false , 'normal' , CapsStyle.NONE);						// Unknown code :)			var segments  = (angle / 8) / 180 * Math.PI;			var distanceControl = this.radius / Math.cos(segments / 2);			this.circleShape.graphics.moveTo(this.radius , 0);			for (var e:int = 1; e <= 8; e ++)			{				var endX = this.radius * Math.cos(e * segments);				var endY = -this.radius * Math.sin(e * segments);				var controlX = distanceControl * Math.cos(e * segments - segments / 2);				var controlY = -distanceControl * Math.sin(e * segments - segments / 2);				this.circleShape.graphics.curveTo(controlX , controlY , endX , endY);			}			// End of unknown code :)		}				/**		 * Resizes the loader		 * @param	int		contextWidth	the width		 * @param	int		contextHeight	the height		 * @param	Number	speed			the speed		 * @return	void		 */		public function resizeLoader(contextWidth:int , contextHeight:int , speed:Number):void		{			// Background			this.fullscreenBackground.graphics.clear();			this.fullscreenBackground.graphics.beginFill(this.backColor);			this.fullscreenBackground.graphics.drawRect(0 , 0 , contextWidth , contextHeight);			this.fullscreenBackground.graphics.endFill();			this.bitmapBackground.x = int((contextWidth - this.bitmapBackground.width) / 2);			this.bitmapBackground.y = int((contextHeight - this.bitmapBackground.height) / 2);			// Loader			this.circleShape.x = int(contextWidth / 2);			this.circleShape.y = int(contextHeight / 2);			// Mask			this.theMask.x = int(contextWidth / 2);			this.theMask.y = int(contextHeight / 2);			Main.debug('Resizes Circular Loader (' + contextWidth + 'x' + contextHeight + ')');		}	}}