package js{	import flash.display.MovieClip;	import flash.events.Event;	import flash.display.Bitmap;	import flash.events.MouseEvent;	import flash.display.Bitmap;	import flash.filters.BlurFilter;	import flash.net.URLRequest;	import flash.net.navigateToURL;	import com.greensock.TweenLite;	import com.greensock.easing.Back;	import com.greensock.easing.Cubic;	import flash.filters.DropShadowFilter;		public class Submenu extends MovieClip	{						private var submenuItems:Array;		private var margin:int;		private var theWidth:int;		private var theShadow:DropShadowFilter;		private var displayed:Boolean;						/**		 * Inits the submenu		 * @param	XML		parameters	the submenu list		 * @param	Bitmap	blackDust	the black dust		 */		public function Submenu(parameters:XML , blackDust:Bitmap)		{			this.visible = false;			this.displayed = false;			this.theWidth = 0;			this.submenuItems = new Array();			this.theShadow = new DropShadowFilter(0 , 0 , 0x000000 , Number(parameters.@shadow_alpha.toString()) , int(parameters.@shadow_radius.toString()) , int(parameters.@shadow_radius.toString()));			this.margin = int(parameters.@submenu_margin.toString());			// Builds the items			for each(var submenu:XML in parameters.link)			{				var theDust:Bitmap = new Bitmap(blackDust.bitmapData.clone());				var item:SubmenuItem = new SubmenuItem(submenu , theDust);				submenuItems.push(item);			}			// Waits for stage			if (stage)				this.addedToStage(null);			else				this.addEventListener(Event.ADDED_TO_STAGE , this.addedToStage);		}		/**		 * Fired when added to stage		 * @param	Event	evt		the event		 * @return	void		 */		private function addedToStage(evt:Event = null):void		{			if (evt != null)				evt.target.removeEventListener(Event.ADDED_TO_STAGE , this.addedToStage);			this.filters = [this.theShadow];			// Prepares items			var theX:int = 0;			for each(var item:SubmenuItem in this.submenuItems)			{				item.x = theX;				this.addChild(item);				theX += item.getWidth() + this.margin;			}			this.theWidth = theX - this.margin;		}				/**		 * Displays the submenu		 * @param	Function	callback	function called when the animation is done		 * @return	void		 */		public function displaySubmenu(callback:Function = null):void		{			// Prepares			this.visible = true;			this.displayed = true;			var menuDelay:Number = 0;			for(var index:int = 0; index < this.numChildren; index++)			{				var item:SubmenuItem = SubmenuItem(this.getChildAt(index));				item.displayItem(menuDelay);				menuDelay += item.getDelayAfter();			}			if (callback != null)				TweenLite.delayedCall(menuDelay , callback);		}				/**		 * Hides the submenu		 * @param	Function	callback	function called when the animation is done		 * @return	void		 */		public function hideSubmenu(callback:Function = null):void		{			// Prepares			this.displayed = false;			var menuDelay:Number = 0;			for(var index:int = 0; index < this.numChildren; index++)			{				var item:SubmenuItem = SubmenuItem(this.getChildAt(index));				item.hideItem(menuDelay);				menuDelay += item.getDelayAfter();			}			if (callback != null)				TweenLite.delayedCall(menuDelay , callback);		}		/**		 * Tells if the submenu is displayed		 * @return	Boolean		 */		public function isDisplayed():Boolean		{			return this.displayed;		}		/**		 * Returns the submenu width		 * @return	int		 */		public function getWidth():int		{			return this.theWidth;		}	}}