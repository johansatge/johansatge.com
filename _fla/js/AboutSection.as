package js{		import flash.display.MovieClip;	import flash.events.Event;	import flash.display.Bitmap;	import flash.events.MouseEvent;	import flash.filters.DropShadowFilter;	import flash.filters.BlurFilter;	import com.greensock.TweenLite;	import com.greensock.easing.Back;	import com.greensock.easing.Quad;	import flash.text.TextFormat;		public class AboutSection extends MovieClip	{		private var XMLParameters:XML;		private var theRadius:int;		private var front:MovieClip;		private var back:MovieClip;		private var frontBackground:MovieClip;		private var backBackground:MovieClip;		private var theShadow:DropShadowFilter;		private var maskedScale:Number;		private var hasBack:Boolean;		private var frontButton:AboutButton;		private var overButton:AboutButton;		private var frontIsHover:Boolean;		private var backIsHover:Boolean;		private var backCallback:Function;		private var flipSpeed:Number;		private var blurAmount:int;		private var theBlur:BlurFilter;			/**		 * Constructor.		 * @param	XML			parameters		the page parameters (XML node)		 * @param	int			radius			section radius		 * @param	Function	backCallback	the return callback		 */		public function AboutSection(parameters:XML , radius:int , backCallback:Function)		{			// Setups vars			this.visible = false;			this.blurAmount = int(parameters.@blur.toString());			this.theBlur = new BlurFilter(0 , 0 , 1);			this.XMLParameters = parameters;			this.backCallback = backCallback;			this.theRadius = radius;			this.theShadow = new DropShadowFilter(0 , 0 , 0x000000 , Number(parameters.@shadow_alpha.toString()) , int(parameters.@shadow_radius.toString()) , int(parameters.@shadow_radius.toString()));			this.maskedScale = Number(parameters.@masked_scale.toString());			this.flipSpeed = Number(parameters.@flip_speed.toString());			this.hasBack = (parameters.back.length() > 0);			this.frontIsHover = false;			this.backIsHover = false;			// Stage			if (stage)				this.addedToStage(null);			else				this.addEventListener(Event.ADDED_TO_STAGE , this.addedToStage);		}		/**		 * Fired when added to stage		 * @param	Event	evt		the event		 * @return	void		 */		private function addedToStage(evt:Event = null):void		{			if (evt != null)				evt.target.removeEventListener(Event.ADDED_TO_STAGE , this.addedToStage);			// Graphics			this.filters = [this.theShadow , this.theBlur];			this.cacheAsBitmap = true;			// Builds front face			this.front = new MovieClip();			this.addChild(this.front);			// Front background			this.frontBackground = new MovieClip();			this.frontBackground.graphics.beginBitmapFill(new GenericBlackDust());			this.frontBackground.graphics.drawCircle(0 , 0 , this.theRadius);			this.frontBackground.graphics.endFill();			this.front.addChild(this.frontBackground);			// Front content			var theFrontFormat:TextFormat = new TextFormat();			theFrontFormat.leading = int(this.XMLParameters.front.@leading.toString());			this.frontContent.titleArea.htmlText = this.XMLParameters.title.toString();			this.frontContent.contentArea.htmlText = this.XMLParameters.front.toString();			this.frontContent.contentArea.setTextFormat(theFrontFormat);			this.front.addChild(this.frontContent);				this.frontContent.mouseEnabled = false;			this.frontContent.mouseChildren = false;			// Front button			this.frontButton = new AboutButton(this.XMLParameters.button.front , this.buttonClick , this.theRadius , new Bitmap(new GenericWhiteDust()));			this.front.addChild(this.frontButton);			this.frontButton.x = -.5; // Ugly hack to prevent blurry text			this.frontButton.y = 0;			// Back content (if needed)			this.back = new MovieClip();			if (!this.hasBack)				return;			// Builds back face			this.addChild(this.back);			// Back background			this.backBackground = new MovieClip();			this.backBackground.graphics.beginFill(0x000000);			this.backBackground.graphics.drawCircle(0 , 0 , this.theRadius);			this.backBackground.graphics.endFill();			this.back.addChild(this.backBackground);			this.backContent.mouseEnabled = false;			this.backContent.mouseChildren = false;			// Front content			var theBackFormat:TextFormat = new TextFormat();			theBackFormat.leading = int(this.XMLParameters.back.@leading.toString());			this.backContent.titleArea.htmlText = this.XMLParameters.title.toString();			this.backContent.contentArea.htmlText = this.XMLParameters.back.toString();			this.backContent.contentArea.setTextFormat(theBackFormat);			this.back.addChild(this.backContent);				this.backContent.mouseChildren = false;			// Back button			this.overButton = new AboutButton(this.XMLParameters.button.back , this.buttonClick , this.theRadius , new Bitmap(new GenericWhiteDust()));			this.back.addChild(this.overButton);			this.overButton.x = -.5; // Ugly hack to prevent blurry text			this.overButton.y = 0;			// Back position			this.back.rotationY = 180;			this.back.rotationZ = 180;		}				/**		 * Displays the section		 * @param	Number		speed		the speed		 * @param	Number		delay		the delay		 * @param	Function	callback	optional callback		 * @return	void		 */		public function displaySection(speed:Number , delay:Number = 0 , callback:Function = null):void		{			// Prepares			this.back.visible = false;			this.rotationX = 0;			this.scaleX = this.maskedScale;			this.scaleY = this.maskedScale;			this.theBlur.blurX = this.blurAmount;			this.theBlur.blurY = this.blurAmount;			this.alpha = 0;			this.visible = true;			TweenLite.to(this , speed , {blurFilter:{blurX:0 , blurY:0} , alpha:1 , scaleX:1 , scaleY:1 , delay:delay , ease:Back.easeOut});			if (callback != null)				TweenLite.delayedCall(speed + delay , callback);			this.front.addEventListener(MouseEvent.MOUSE_MOVE , this.frontButton.moveButton);			this.frontBackground.addEventListener(MouseEvent.ROLL_OVER , this.displayFrontButton);			this.front.addEventListener(MouseEvent.ROLL_OUT , this.prepareHideFrontButton);			if (this.hasBack)			{				this.back.addEventListener(MouseEvent.MOUSE_MOVE , this.overButton.moveButton);				this.backBackground.addEventListener(MouseEvent.ROLL_OVER , this.displayBackButton);				this.back.addEventListener(MouseEvent.ROLL_OUT , this.prepareHideBackButton);			}		}				/**		 * Hides the section		 * @param	Number			 * @param	Number		speed		the speed		 * @param	Number		delay		the delay		 * @param	Function	callback	optional callback		 * @return	void		 */		public function hideSection(speed:Number , delay:Number = 0 , callback:Function = null):void		{			this.front.removeEventListener(MouseEvent.MOUSE_MOVE , this.frontButton.moveButton);			this.frontBackground.removeEventListener(MouseEvent.ROLL_OVER , this.displayFrontButton);			this.front.removeEventListener(MouseEvent.ROLL_OUT , this.prepareHideFrontButton);			if (this.hasBack)			{				this.back.removeEventListener(MouseEvent.MOUSE_MOVE , this.overButton.moveButton);				this.backBackground.removeEventListener(MouseEvent.ROLL_OVER , this.displayBackButton);				this.back.removeEventListener(MouseEvent.ROLL_OUT , this.prepareHideBackButton);			}			TweenLite.to(this , speed , {blurFilter:{blurX:blurAmount , blurY:blurAmount} , alpha:0 , scaleX:maskedScale , scaleY:maskedScale , delay:delay , ease:Quad.easeOut});			TweenLite.delayedCall((speed / 2) + delay , sectionHidden);		}		/**		 * Called when the section has been hidden		 * @param	Function	callback	optional callback		 * @return	void		 */		public function sectionHidden(callback:Function = null):void		{			this.visible = false;			this.rotationX = 0;			this.front.visible = true;			this.back.visible = false;			this.front.removeEventListener(MouseEvent.MOUSE_MOVE , this.frontButton.moveButton);			this.front.removeEventListener(MouseEvent.MOUSE_OVER , displayFrontButton);			this.front.removeEventListener(MouseEvent.MOUSE_OUT , prepareHideFrontButton);			if (callback != null)				callback();		}		/**		 * Displays the front button		 * @param	MouseEvent	evt		the mouse event		 * @return	void		 */		private function displayFrontButton(evt:MouseEvent):void		{			this.frontIsHover = true;			TweenLite.killDelayedCallsTo(this.hideFrontButton);			this.frontButton.displayButton();		}		/**		 * Hides the front button after a delay		 * @param	MouseEvent	evt		the mouse event		 * @return	void		 */		private function prepareHideFrontButton(evt:MouseEvent):void		{			this.frontIsHover = false;			TweenLite.delayedCall(this.frontButton.getPersistence() , this.hideFrontButton);		}		/**		 * Hides the front button		 * @return	void		 */		private function hideFrontButton():void		{			if (!this.frontIsHover)				this.frontButton.hideButton();		}				/**		 * Displays the front button		 * @param	MouseEvent	evt		the mouse event		 * @return	void		 */		private function displayBackButton(evt:MouseEvent):void		{			this.backIsHover = true;			TweenLite.killDelayedCallsTo(this.hideBackButton);			this.overButton.displayButton();		}		/**		 * Hides the front button after a delay		 * @param	MouseEvent	evt		the mouse event		 * @return	void		 */		private function prepareHideBackButton(evt:MouseEvent):void		{			this.backIsHover = false;			TweenLite.delayedCall(this.overButton.getPersistence() , this.hideBackButton);		}		/**		 * Hides the front button		 * @return	void		 */		private function hideBackButton():void		{			if (!this.backIsHover)				this.overButton.hideButton();		}				/**		 * Called when the section button is clicked		 * @return	void		 */		public function buttonClick():void		{			if (this.hasBack)				this.flip();			else				this.backCallback();		}				/**		 * Flips		 * @return	void		 */		private function flip():void		{			var targetRotation:int = (this.rotationX == 180) ? 0 : 180;			TweenLite.to(this , this.flipSpeed , {rotationX:targetRotation , onUpdate:flipping , onUpdateParams:[targetRotation] , ease:Back.easeOut});						TweenLite.to(this , this.flipSpeed / 2 , {blurFilter:{blurY:blurAmount} , overwrite:false});						TweenLite.to(this , this.flipSpeed / 2 , {delay:flipSpeed / 2 , blurFilter:{blurY:0} , overwrite:false});					}				/**		 * Flipping		 * @param	int	targetRotation		180 (displaying back) or 0 (coming back to front)		 * @return	void		 */		private function flipping(targetRotation:int):void		{			if (this.rotationX >= 90 && targetRotation == 180)			{				this.front.visible = false;				this.back.visible = true;			}			if (this.rotationX <= 90 && targetRotation == 0)			{				this.front.visible = true;				this.back.visible = false;			}		}				 	}}